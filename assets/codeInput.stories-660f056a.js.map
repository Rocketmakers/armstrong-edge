{"version":3,"file":"codeInput.stories-660f056a.js","sources":["../../src/components/codeInput/codeInput.utils.ts","../../src/components/codeInput/codeInput.component.tsx"],"sourcesContent":["import { NullOrUndefined } from '../../types';\nimport { CodeInputPartDefinition } from './codeInput.types';\n\n/**\n * Get the required character length from a code input part definition.\n * @param part The part definition.\n * @returns The required character length for the part\n */\nexport function getLengthFromPart<T extends NullOrUndefined<string>>(part: CodeInputPartDefinition<T>) {\n  if (typeof part === 'number') {\n    return part;\n  }\n  if (typeof part === 'string') {\n    return 0;\n  }\n  return part.length;\n}\n","import * as React from 'react';\n\nimport { IBindingProps, useBindingState, useForm } from '../../form';\nimport { ArmstrongFCExtensions, ArmstrongFCReturn, ArmstrongVFCProps, DisplaySize, NullOrUndefined } from '../../types';\nimport { concat, findLastIndex } from '../../utils';\nimport { useArmstrongConfig } from '../config';\nimport { Input, ITextInputProps } from '../input';\nimport { IInputWrapperProps } from '../inputWrapper';\nimport { Label } from '../label';\nimport { StatusWrapper } from '../statusWrapper';\nimport { ValidationErrors } from '../validationErrors';\nimport { CodeInputPartDefinition } from './codeInput.types';\nimport { getLengthFromPart } from './codeInput.utils';\n\nimport './codeInput.theme.css';\n\nexport interface ICodeInputPartProps<TBind extends NullOrUndefined<string>> extends ITextInputProps<TBind> {\n  /** The given length of this part. If this is a string, the string will be rendered. */\n  part: CodeInputPartDefinition<TBind>;\n}\n\n/** an individual input from the CodeInput */\nconst CodeInputPart = React.forwardRef<HTMLInputElement, ICodeInputPartProps<NullOrUndefined<string>>>(\n  ({ bind, part, ...inputProps }, ref) => {\n    const length = React.useMemo(() => getLengthFromPart(part), [part]);\n\n    if (typeof part === 'string') {\n      return <p className=\"arm-code-input-part-text\">{part}</p>;\n    }\n\n    if (typeof part === 'number') {\n      return (\n        <Input\n          ref={ref}\n          bind={bind as IBindingProps<string | null>}\n          {...inputProps}\n          className=\"arm-code-input-part-input\"\n          style={{ '--arm-code-input-length': length } as React.CSSProperties}\n          data-length={length}\n          onClick={event => event.currentTarget.select()}\n          maxLength={part}\n        />\n      );\n    }\n\n    const { className, ...textInputProps } = part;\n\n    return (\n      <Input\n        ref={ref}\n        bind={bind as IBindingProps<string | null>}\n        className={concat('arm-code-input-part-input', className)}\n        style={\n          {\n            ...(textInputProps.style || {}),\n            '--arm-code-input-length': length,\n          } as React.CSSProperties\n        }\n        data-length={length}\n        onClick={event => event.currentTarget.select()}\n        {...inputProps}\n        {...textInputProps}\n        maxLength={part.length}\n        displaySize={part.displaySize}\n      />\n    );\n  }\n  // type assertion to ensure generic works with RefForwarded component\n  // DO NOT CHANGE TYPE WITHOUT CHANGING THIS, FIND TYPE BY INSPECTING React.forwardRef\n) as (<TBind extends NullOrUndefined<string>>(\n  props: ArmstrongVFCProps<ICodeInputPartProps<TBind>, HTMLInputElement>\n) => ArmstrongFCReturn) &\n  ArmstrongFCExtensions<ICodeInputPartProps<NullOrUndefined<string>>>;\n\nCodeInputPart.displayName = 'CodeInputPart';\n\n/** A text input where the value is split between multiple inputs, where focus is automatically moved between them as the user edits */\nexport interface ICodeInputProps<TBind extends NullOrUndefined<string>>\n  extends Pick<\n      IInputWrapperProps,\n      | 'scrollValidationErrorsIntoView'\n      | 'validationMode'\n      | 'errorIcon'\n      | 'disabled'\n      | 'pending'\n      | 'error'\n      | 'statusPosition'\n      | 'hideIconOnStatus'\n      | 'validationErrorMessages'\n      | 'leftOverlay'\n      | 'rightOverlay'\n      | 'statusClassName'\n      | 'validationErrorsClassName'\n      | 'labelClassName'\n      | 'labelId'\n      | 'disableOnPending'\n    >,\n    Omit<React.RefAttributes<HTMLDivElement>, 'ref'> {\n  /** Prop for binding to an Armstrong form binder (see forms documentation) */\n  bind?: IBindingProps<TBind>;\n\n  /** The current value of the input */\n  value?: TBind;\n\n  /** Fired when the code input changes */\n  onChange?: (newValue: TBind) => void;\n\n  /**\n   * The parts of the code input\n   * Can be a number representing the length of an input, e.g. [1,1,1]\n   * Can be a string representing a piece of text in-between inputs, e.g. [1,1,'-',1,1]\n   * Can be an object representing an input with some properties\n   */\n  parts: CodeInputPartDefinition<TBind>[];\n\n  /** Optional className for the code input */\n  className?: string;\n\n  /** which size variant to use */\n  displaySize?: DisplaySize;\n\n  /** Some optional label content */\n  label?: React.ReactNode;\n\n  /** Should the label show a required indicator? */\n  required?: boolean;\n\n  /** Symbol to use as the required indicator on the label, defaults to \"*\" */\n  requiredIndicator?: React.ReactNode;\n}\n\nexport const CodeInput = React.forwardRef<HTMLDivElement, ICodeInputProps<NullOrUndefined<string>>>(\n  (\n    {\n      className,\n      parts,\n      bind,\n      onChange,\n      validationMode,\n      validationErrorMessages,\n      errorIcon,\n      error,\n      value,\n      pending,\n      statusPosition,\n      leftOverlay,\n      rightOverlay,\n      scrollValidationErrorsIntoView,\n      displaySize,\n      label,\n      required,\n      requiredIndicator,\n      hideIconOnStatus,\n      statusClassName,\n      validationErrorsClassName,\n      labelClassName,\n      labelId,\n      disableOnPending,\n      disabled,\n      ...nativeProps\n    },\n    ref\n  ) => {\n    const globals = useArmstrongConfig({\n      validationMode,\n      inputStatusPosition: statusPosition,\n      inputDisplaySize: displaySize,\n      requiredIndicator,\n      hideInputErrorIconOnStatus: hideIconOnStatus,\n      disableControlOnPending: disableOnPending,\n      scrollValidationErrorsIntoView,\n      validationErrorIcon: errorIcon,\n    });\n\n    const inputRefs = React.useRef<(HTMLInputElement | null | undefined)[]>([]);\n\n    const [boundValue, setBoundValue, bindConfig] = useBindingState(bind, {\n      onChange,\n      validationErrorMessages,\n      validationMode: globals.validationMode,\n      validationErrorIcon: globals.validationErrorIcon,\n      value,\n    });\n\n    const goNextPart = React.useCallback(\n      (partIndex: number) => {\n        const nextIndex = parts.slice(partIndex + 1).findIndex(part => typeof part !== 'string') + partIndex + 1;\n\n        if (nextIndex !== -1) {\n          inputRefs.current[nextIndex]?.focus();\n        }\n      },\n      [parts]\n    );\n\n    /** @todo - why is focussing selecting before the final character? */\n    const goPreviousPart = React.useCallback(\n      (partIndex: number) => {\n        const previousIndex = findLastIndex(parts.slice(0, partIndex), part => typeof part !== 'string');\n\n        if (previousIndex !== -1) {\n          inputRefs.current[previousIndex]?.focus();\n        }\n      },\n      [parts]\n    );\n\n    const getValueForPart = React.useCallback(\n      (partIndex: number, incomingValue: NullOrUndefined<string>) => {\n        const sliceStart = parts\n          .slice(0, partIndex)\n          .reduce<number>((output, part) => output + getLengthFromPart(part), 0);\n        const sliceEnd = sliceStart + getLengthFromPart(parts[partIndex]);\n\n        return incomingValue?.slice(sliceStart, sliceEnd) || '';\n      },\n      [parts]\n    );\n\n    const onPartValueChange = React.useCallback(\n      (event: React.ChangeEvent<HTMLInputElement>, partIndex: number) => {\n        const currentPartLength = getLengthFromPart(parts[partIndex]);\n\n        const currentPartValue = event.currentTarget.value || '';\n\n        if (currentPartValue.length >= currentPartLength) {\n          goNextPart(partIndex);\n        }\n      },\n      [parts, goNextPart]\n    );\n\n    const onPaste = React.useCallback(\n      (event: React.ClipboardEvent<HTMLInputElement>) => {\n        event.preventDefault();\n        const pasteValue = event.clipboardData.getData('text/plain');\n        const target = event.target as HTMLInputElement;\n\n        const partIndex = inputRefs.current.indexOf(target);\n\n        const selectionStart = Math.min(target.selectionStart ?? 0, target.selectionEnd ?? 0);\n        const selectionEnd = Math.max(target.selectionStart ?? 0, target.selectionEnd ?? 0);\n\n        const insertionStart =\n          new Array(partIndex).fill(null).reduce((memo, _, i) => {\n            const part = parts[i];\n            return memo + getLengthFromPart(part);\n          }, 0) + selectionStart;\n\n        const insertionEnd = insertionStart + (selectionEnd - selectionStart);\n\n        const startSlice = boundValue?.slice(0, insertionStart) ?? '';\n        const endSlice = boundValue?.slice(insertionEnd) ?? '';\n\n        const newValue = startSlice + pasteValue + endSlice;\n\n        setBoundValue(newValue);\n      },\n      [setBoundValue, boundValue, parts]\n    );\n\n    const boundValueArray = React.useMemo(() => {\n      return parts.map((_, partIndex) => getValueForPart(partIndex, boundValue));\n    }, [getValueForPart, parts, boundValue]);\n\n    const onKeyDown = React.useCallback(\n      (event: React.KeyboardEvent<HTMLInputElement>, partIndex: number, part: number) => {\n        switch (event.key) {\n          case 'Backspace': {\n            if (event.currentTarget.value?.length <= 0 && partIndex > 0) {\n              goPreviousPart(partIndex);\n            }\n            break;\n          }\n          case 'ArrowLeft': {\n            if (event.currentTarget.selectionStart === 0 && partIndex > 0) {\n              goPreviousPart(partIndex);\n            }\n            break;\n          }\n          case 'ArrowRight': {\n            if (event.currentTarget.selectionEnd === getLengthFromPart(part) && partIndex < parts.length) {\n              goNextPart(partIndex);\n            }\n            break;\n          }\n          default: {\n            break;\n          }\n        }\n      },\n      [goPreviousPart, goNextPart, parts]\n    );\n\n    interface IFormState {\n      parts: string[];\n    }\n\n    const { formProp, formState } = useForm<IFormState>({ parts: boundValueArray });\n\n    React.useEffect(() => {\n      setBoundValue?.(formState?.parts?.join(''));\n      // eslint-disable-next-line react-hooks/exhaustive-deps -- we don't want the trigger the effect when the function is re-defined\n    }, [formState]);\n\n    const showLeftOverlay =\n      leftOverlay &&\n      (globals.inputStatusPosition !== 'left' ||\n        !globals.hideInputErrorIconOnStatus ||\n        (!pending && !bindConfig.shouldShowValidationErrorIcon));\n\n    const showRightOverlay =\n      rightOverlay &&\n      (globals.inputStatusPosition !== 'right' ||\n        !globals.hideInputErrorIconOnStatus ||\n        (!pending && !bindConfig.shouldShowValidationErrorIcon));\n\n    return (\n      <>\n        <div ref={ref} title=\"Code input\" {...nativeProps}>\n          {label && (\n            <Label\n              className={concat('arm-code-input-label', labelClassName)}\n              id={labelId}\n              required={required}\n              requiredIndicator={globals.requiredIndicator}\n              displaySize={globals.inputDisplaySize}\n            >\n              {label}\n            </Label>\n          )}\n          <div className={concat('arm-code-input', className)}>\n            <StatusWrapper\n              error={error || !!bindConfig.validationErrorMessages.length}\n              errorIcon={bindConfig.validationErrorIcon}\n              statusPosition={globals.inputStatusPosition}\n              pending={pending}\n              validationMode={bindConfig.validationMode}\n              className={statusClassName}\n            >\n              <>\n                {showLeftOverlay && leftOverlay}\n                {parts?.map((part, index) => (\n                  <CodeInputPart<string>\n                    type=\"text\"\n                    bind={formProp('parts', index).bind()}\n                    part={part}\n                    key={index}\n                    onChange={event => onPartValueChange(event, index)}\n                    onKeyDown={event => onKeyDown(event, index, +part)}\n                    onPaste={onPaste}\n                    disabled={disabled || (pending && globals.disableControlOnPending)}\n                    ref={r => {\n                      inputRefs.current[index] = r;\n                    }}\n                    displaySize={globals.inputDisplaySize}\n                  />\n                ))}\n                {showRightOverlay && rightOverlay}\n              </>\n            </StatusWrapper>\n          </div>\n        </div>\n\n        {!!bindConfig.validationErrorMessages?.length && bindConfig.shouldShowValidationErrorMessage && (\n          <ValidationErrors\n            className={validationErrorsClassName}\n            validationErrors={bindConfig.validationErrorMessages}\n            scrollIntoView={globals.scrollValidationErrorsIntoView}\n          />\n        )}\n      </>\n    );\n  }\n  // type assertion to ensure generic works with RefForwarded component\n  // DO NOT CHANGE TYPE WITHOUT CHANGING THIS, FIND TYPE BY INSPECTING React.forwardRef\n) as (<TBind extends NullOrUndefined<string>>(\n  props: ArmstrongVFCProps<ICodeInputProps<TBind>, HTMLDivElement>\n) => ArmstrongFCReturn) &\n  ArmstrongFCExtensions<ICodeInputProps<NullOrUndefined<string>>>;\n\nCodeInput.displayName = 'Code Input';\n"],"names":["getLengthFromPart","part","CodeInputPart","React.forwardRef","bind","inputProps","ref","length","React.useMemo","jsx","Input","event","className","textInputProps","concat","CodeInput","parts","onChange","validationMode","validationErrorMessages","errorIcon","error","value","pending","statusPosition","leftOverlay","rightOverlay","scrollValidationErrorsIntoView","displaySize","label","required","requiredIndicator","hideIconOnStatus","statusClassName","validationErrorsClassName","labelClassName","labelId","disableOnPending","disabled","nativeProps","globals","useArmstrongConfig","inputRefs","React.useRef","boundValue","setBoundValue","bindConfig","useBindingState","goNextPart","React.useCallback","partIndex","nextIndex","_a","goPreviousPart","previousIndex","findLastIndex","getValueForPart","incomingValue","sliceStart","output","sliceEnd","onPartValueChange","currentPartLength","onPaste","pasteValue","target","selectionStart","selectionEnd","insertionStart","memo","_","i","insertionEnd","startSlice","endSlice","newValue","boundValueArray","onKeyDown","formProp","formState","useForm","React.useEffect","showLeftOverlay","showRightOverlay","jsxs","Fragment","Label","StatusWrapper","index","r","ValidationErrors"],"mappings":"85BAQO,SAASA,EAAqDC,EAAkC,CACjG,OAAA,OAAOA,GAAS,SACXA,EAEL,OAAOA,GAAS,SACX,EAEFA,EAAK,MACd,CCMA,MAAAC,EAAAC,EAAA,WAA4B,CAAA,CAAA,KAAAC,EAAA,KAAAH,EAAA,GAAAI,CAAA,EAAAC,IAAA,CAExB,MAAAC,EAAAC,EAAAA,QAAA,IAAAR,EAAAC,CAAA,EAAA,CAAAA,CAAA,CAAA,EAEA,GAAA,OAAAA,GAAA,SACE,OAAAQ,EAAA,IAAA,CAAA,UAAA,2BAAA,SAAAR,CAAA,CAAA,EAGF,GAAA,OAAAA,GAAA,SACE,OAAAQ,EACEC,EAAC,CAAA,IAAAJ,EACC,KAAAF,EACA,GAAAC,EACI,UAAA,4BACM,MAAA,CAAA,0BAAAE,CAAA,EACiC,cAAAA,EAC9B,QAAAI,GAAAA,EAAA,cAAA,OAAA,EACgC,UAAAV,CAClC,CAAA,EAKjB,KAAA,CAAA,UAAAW,EAAA,GAAAC,CAAA,EAAAZ,EAEA,OAAAQ,EACEC,EAAC,CAAA,IAAAJ,EACC,KAAAF,EACA,UAAAU,EAAA,4BAAAF,CAAA,EACwD,MAAA,CAEtD,GAAAC,EAAA,OAAA,CAAA,EAC+B,0BAAAN,CACF,EAC7B,cAAAA,EAEW,QAAAI,GAAAA,EAAA,cAAA,OAAA,EACgC,GAAAN,EACzC,GAAAQ,EACA,UAAAZ,EAAA,OACY,YAAAA,EAAA,WACE,CAAA,CACpB,CAKN,EAKAC,EAAA,YAAA,gBAyDO,MAAAa,EAAAZ,EAAA,WAAwB,CAAA,CAE3B,UAAAS,EACE,MAAAI,EACA,KAAAZ,EACA,SAAAa,EACA,eAAAC,EACA,wBAAAC,EACA,UAAAC,EACA,MAAAC,EACA,MAAAC,EACA,QAAAC,EACA,eAAAC,GACA,YAAAC,EACA,aAAAC,EACA,+BAAAC,GACA,YAAAC,GACA,MAAAC,EACA,SAAAC,GACA,kBAAAC,GACA,iBAAAC,GACA,gBAAAC,GACA,0BAAAC,GACA,eAAAC,GACA,QAAAC,GACA,iBAAAC,GACA,SAAAC,GACA,GAAAC,EACG,EAAAjC,KAAA,OAIL,MAAAkC,EAAAC,GAAA,CAAmC,eAAAvB,EACjC,oBAAAM,GACqB,iBAAAI,GACH,kBAAAG,GAClB,2BAAAC,GAC4B,wBAAAK,GACH,+BAAAV,GACzB,oBAAAP,CACqB,CAAA,EAGvBsB,EAAAC,SAAA,CAAA,CAAA,EAEA,CAAAC,EAAAC,EAAAC,CAAA,EAAAC,GAAA3C,EAAA,CAAsE,SAAAa,EACpE,wBAAAE,EACA,eAAAqB,EAAA,eACwB,oBAAAA,EAAA,oBACK,MAAAlB,CAC7B,CAAA,EAGF0B,EAAAC,EAAA,YAAyBC,GAAA,OAErB,MAAAC,EAAAnC,EAAA,MAAAkC,EAAA,CAAA,EAAA,UAAAjD,GAAA,OAAAA,GAAA,QAAA,EAAAiD,EAAA,EAEAC,IAAA,MACEC,EAAAV,EAAA,QAAAS,CAAA,IAAA,MAAAC,EAAA,QACF,EACF,CAAApC,CAAA,CACM,EAIRqC,EAAAJ,EAAA,YAA6BC,GAAA,OAEzB,MAAAI,EAAAC,GAAAvC,EAAA,MAAA,EAAAkC,CAAA,EAAAjD,GAAA,OAAAA,GAAA,QAAA,EAEAqD,IAAA,MACEF,EAAAV,EAAA,QAAAY,CAAA,IAAA,MAAAF,EAAA,QACF,EACF,CAAApC,CAAA,CACM,EAGRwC,EAAAP,EAAA,YAA8B,CAAAC,EAAAO,IAAA,CAE1B,MAAAC,EAAA1C,EAAA,MAAA,EAAAkC,CAAA,EAAA,OAAA,CAAAS,EAAA1D,IAAA0D,EAAA3D,EAAAC,CAAA,EAAA,CAAA,EAGA2D,EAAAF,EAAA1D,EAAAgB,EAAAkC,CAAA,CAAA,EAEA,OAAAO,GAAA,YAAAA,EAAA,MAAAC,EAAAE,KAAA,EAAqD,EACvD,CAAA5C,CAAA,CACM,EAGR6C,GAAAZ,EAAA,YAAgC,CAAAtC,EAAAuC,IAAA,CAE5B,MAAAY,EAAA9D,EAAAgB,EAAAkC,CAAA,CAAA,GAEAvC,EAAA,cAAA,OAAA,IAEA,QAAAmD,GACEd,EAAAE,CAAA,CACF,EACF,CAAAlC,EAAAgC,CAAA,CACkB,EAGpBe,GAAAd,EAAA,YAAsBtC,GAAA,CAElBA,EAAA,eAAA,EACA,MAAAqD,EAAArD,EAAA,cAAA,QAAA,YAAA,EACAsD,EAAAtD,EAAA,OAEAuC,EAAAR,EAAA,QAAA,QAAAuB,CAAA,EAEAC,EAAA,KAAA,IAAAD,EAAA,gBAAA,EAAAA,EAAA,cAAA,CAAA,EACAE,EAAA,KAAA,IAAAF,EAAA,gBAAA,EAAAA,EAAA,cAAA,CAAA,EAEAG,EAAA,IAAA,MAAAlB,CAAA,EAAA,KAAA,IAAA,EAAA,OAAA,CAAAmB,GAAAC,GAAAC,KAAA,CAEI,MAAAtE,GAAAe,EAAAuD,EAAA,EACA,OAAAF,GAAArE,EAAAC,EAAA,CAAoC,EAAA,CAAA,EAAAiE,EAGxCM,GAAAJ,GAAAD,EAAAD,GAEAO,IAAA7B,GAAA,YAAAA,EAAA,MAAA,EAAAwB,KAAA,GACAM,IAAA9B,GAAA,YAAAA,EAAA,MAAA4B,MAAA,GAEAG,GAAAF,GAAAT,EAAAU,GAEA7B,EAAA8B,EAAA,CAAsB,EACxB,CAAA9B,EAAAD,EAAA5B,CAAA,CACiC,EAGnC4D,GAAApE,EAAAA,QAAA,IACEQ,EAAA,IAAA,CAAAsD,EAAApB,IAAAM,EAAAN,EAAAN,CAAA,CAAA,EAAyE,CAAAY,EAAAxC,EAAA4B,CAAA,CAAA,EAG3EiC,GAAA5B,EAAA,YAAwB,CAAAtC,EAAAuC,EAAAjD,IAAA,OAEpB,OAAAU,EAAA,IAAA,CAAmB,IAAA,YAAA,GAEfyC,EAAAzC,EAAA,cAAA,QAAA,YAAAyC,EAAA,SAAA,GAAAF,EAAA,GACEG,EAAAH,CAAA,EAEF,KAAA,CACF,IAAA,YAAA,CAEEvC,EAAA,cAAA,iBAAA,GAAAuC,EAAA,GACEG,EAAAH,CAAA,EAEF,KAAA,CACF,IAAA,aAAA,CAEEvC,EAAA,cAAA,eAAAX,EAAAC,CAAA,GAAAiD,EAAAlC,EAAA,QACEgC,EAAAE,CAAA,EAEF,KAAA,CAIF,CACF,EACF,CAAAG,EAAAL,EAAAhC,CAAA,CACkC,EAOpC,CAAA,SAAA8D,GAAA,UAAAC,CAAA,EAAAC,EAAA,CAAA,MAAAJ,EAAA,CAAA,EAEAK,EAAAA,UAAA,IAAA,OACEpC,GAAA,MAAAA,GAAAO,EAAA2B,GAAA,YAAAA,EAAA,QAAA,YAAA3B,EAAA,KAAA,IAA0C,EAAA,CAAA2B,CAAA,CAAA,EAI5C,MAAAG,GAAAzD,IAAAe,EAAA,sBAAA,QAAA,CAAAA,EAAA,4BAAA,CAAAjB,GAAA,CAAAuB,EAAA,+BAMAqC,GAAAzD,IAAAc,EAAA,sBAAA,SAAA,CAAAA,EAAA,4BAAA,CAAAjB,GAAA,CAAAuB,EAAA,+BAMA,OAAAsC,EAAAC,EAAA,CAAA,SAAA,CAEID,EAAA,MAAA,CAAA,IAAA9E,GAAA,MAAA,aAAA,GAAAiC,GAAA,SAAA,CACGV,GAAApB,EACC6E,GAAC,CAAA,UAAAxE,EAAA,uBAAAqB,EAAA,EACyD,GAAAC,GACpD,SAAAN,GACJ,kBAAAU,EAAA,kBAC2B,YAAAA,EAAA,iBACN,SAAAX,CAEpB,CAAA,EACHpB,EAAA,MAAA,CAAA,UAAAK,EAAA,iBAAAF,CAAA,EAAA,SAAAH,EAGA8E,GAAC,CAAA,MAAAlE,GAAA,CAAA,CAAAyB,EAAA,wBAAA,OACsD,UAAAA,EAAA,oBAC/B,eAAAN,EAAA,oBACE,QAAAjB,EACxB,eAAAuB,EAAA,eAC2B,UAAAb,GAChB,SAAAmD,EAAAC,EAAA,CAAA,SAAA,CAGRH,IAAAzD,EAAmBT,GAAA,YAAAA,EAAA,IAAA,CAAAf,EAAAuF,IAAA/E,EAElBP,EAAC,CAAA,KAAA,OACM,KAAA4E,GAAA,QAAAU,CAAA,EAAA,KAAA,EAC+B,KAAAvF,EACpC,SAAAU,GAAAkD,GAAAlD,EAAA6E,CAAA,EAEiD,UAAA7E,GAAAkE,GAAAlE,EAAA6E,EAAA,CAAAvF,CAAA,EACA,QAAA8D,GACjD,SAAAzB,IAAAf,GAAAiB,EAAA,wBAC0C,IAAAiD,GAAA,CAExC/C,EAAA,QAAA8C,CAAA,EAAAC,CAA2B,EAC7B,YAAAjD,EAAA,gBACqB,EAAAgD,CARhB,GAURL,IAAAzD,CACoB,EAAA,CACvB,CAAA,EAAA,CAEJ,EAAA,EACF,CAAA,GAAA0B,EAAAN,EAAA,0BAAA,MAAAM,EAAA,SAAAN,EAAA,kCAAArC,EAGEiF,GAAC,CAAA,UAAAxD,GACY,iBAAAY,EAAA,wBACkB,eAAAN,EAAA,8BACL,CAAA,CAC1B,CAAA,CAAA,CAEJ,CAKN,EAKAzB,EAAA,YAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}