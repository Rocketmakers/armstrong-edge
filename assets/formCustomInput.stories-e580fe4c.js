import{M as h,A as c}from"./chunk-HLWAVYOI-ce9306b9.js";import{j as t,a as n,F as m}from"./jsx-runtime-eae7a151.js";import{u as p}from"./index-f875e932.js";import"./iframe-80a9d828.js";import"../sb-preview/runtime.js";import"./index-c4905b50.js";import"./_commonjsHelpers-042e6b4d.js";import"./react-18-d3dde439.js";import"./index-07d1f67e.js";import"./chunk-ZGA76URP-2b404cd8.js";import"./isNativeReflectConstruct-30e719dd.js";import"./index-11d98b33.js";import"./extends-98964cd2.js";import"./index-ec0b3b5e.js";import"./_baseIsEqual-62e1ad13.js";import"./uniq-4dce63e4.js";import"./index-356e4a49.js";const o=()=>null,l=()=>null,d=()=>null,s=()=>null,i=()=>null;try{o.displayName="ConfigExample",o.__docgenInfo={description:"",displayName:"ConfigExample",props:{validationErrors:{defaultValue:null,description:"Any current validation errors, usually from an API request.",name:"validationErrors",required:!1,type:{name:"IValidationError[]"}},validationSchema:{defaultValue:null,description:`Optional client side validation schema.
- Uses a type safe wrapper around the zod framework.`,name:"validationSchema",required:!1,type:{name:"IFunctionValidationSchema<unknown>"}},validationMode:{defaultValue:null,description:"How to display validation errors\n- `icon` displays an error icon in the event of a validation error.\n- `message` displays a supplied error message in the event of a validation error.\n- `both` displays both the icon and the message.",name:"validationMode",required:!1,type:{name:"enum",value:[{value:'"icon"'},{value:'"message"'},{value:'"both"'}]}},validationErrorIcon:{defaultValue:{value:"warning"},description:"An optional icon to use for validation errors in place of the default.",name:"validationErrorIcon",required:!1,type:{name:"Element"}},autoValidate:{defaultValue:null,description:"should the input validate automatically against the provided schema? Default: `true`",name:"autoValidate",required:!1,type:{name:"boolean"}},logSchemaErrors:{defaultValue:null,description:"Will log validation schema errors to the console for debugging",name:"logSchemaErrors",required:!1,type:{name:"boolean"}}}}}catch{}try{l.displayName="HookReturnExample",l.__docgenInfo={description:"",displayName:"HookReturnExample",props:{formState:{defaultValue:null,description:`The live form state object.
- The root reference is redefined on any change so this can be used as a hook dependency.
- References below the root are smart and only redefined when data beneath them has changed, so use the most granular possible dependencies in your hooks!`,name:"formState",required:!0,type:{name:"{} | undefined"}},formProp:{defaultValue:null,description:'The root method used to access a property within the form data object.\n- Receives a strictly typed set of args for targeting nested properties within a complex data object.\n- Can also allow targeting objects within an array by requesting an index number rather than a key.\n- The args passed to `formProp` form a "key chain" which is then used to access properties within the data object.\n@returns a set of tools for the property in question, notably `bind` and `set`.',name:"formProp",required:!0,type:{name:"IFormProp<{}>"}},resetFormData:{defaultValue:null,description:'Resets user inputted form data back to the most recent "initial" value passed into the hook.',name:"resetFormData",required:!0,type:{name:"() => void"}},getFormData:{defaultValue:null,description:"Returns all current form data as an object\n- Will match the value of `formState` but useful as a light dependency for hooks that need to access the data functionally.",name:"getFormData",required:!0,type:{name:"() => {} | undefined"}},setFormData:{defaultValue:null,description:`Sets the entire form data object to a new value
@param newData The data to set as the active form data.`,name:"setFormData",required:!0,type:{name:"(newData: {}) => void"}},clearClientValidationErrors:{defaultValue:null,description:`Clears all client validation errors for the current form state.
@param identifiers an optional array of validation error identifiers, if passed, only errors that match the identifier will be deleted.`,name:"clearClientValidationErrors",required:!0,type:{name:"(...identifiers: string[]) => void"}},addValidationError:{defaultValue:null,description:`Adds one or more validation errors to the current form state.
- Validation errors consist of a key to target the property, and a message to display.
@param validationErrors The errors to add to the current state.`,name:"addValidationError",required:!0,type:{name:"(...validationErrors: IValidationError[]) => void"}},validate:{defaultValue:null,description:`Runs all validators in the validators schema again the current form state.
@param setAllTouched Whether to set all inputs to "touched" before running the validator, default: true
@param silent A boolean representing whether validation errors should be dispatched to the form elements`,name:"validate",required:!0,type:{name:"(setAllTouched?: boolean | undefined, silent?: boolean | undefined) => boolean"}},isValid:{defaultValue:null,description:"Live boolean representing the validity of the current form based on the validation schema.",name:"isValid",required:!0,type:{name:"boolean"}},touchAll:{defaultValue:null,description:"Sets the global touch state to true for the context of this form hook",name:"touchAll",required:!0,type:{name:"() => void"}},resetTouchedState:{defaultValue:null,description:'Marks all controls as "untouched" essentially resetting the form in terms of user interaction',name:"resetTouchedState",required:!0,type:{name:"() => void"}},allTouched:{defaultValue:null,description:"Live boolean representing whether the global touch has been set to true",name:"allTouched",required:!0,type:{name:"boolean"}}}}}catch{}try{d.displayName="FormPropExample",d.__docgenInfo={description:"",displayName:"FormPropExample",props:{bind:{defaultValue:null,description:"Binds an input to a `formProp`, the result can be passed to any component `bind` prop.\n@param config Optional config for the binding.\n@returns A set of binding props for use by the input or child form component.",name:"bind",required:!0,type:{name:"(config?: IBindConfig<unknown> | undefined) => IBindingProps<unknown>"}},set:{defaultValue:null,description:`Sets the value of a field in the form state.
@param newValue The value to set the field to.
@returns Binding props for chaining.`,name:"set",required:!0,type:{name:"(newValue: unknown) => BindingTools<unknown>"}},clear:{defaultValue:null,description:`Clears the value of a field in the form state, setting it to undefined
@returns Binding props for chaining.`,name:"clear",required:!0,type:{name:"() => BindingTools<unknown>"}},get:{defaultValue:null,description:`Gets the current value for a field within the form state.
@returns the value if set, or undefined.`,name:"get",required:!0,type:{name:"() => unknown"}},addValidationError:{defaultValue:null,description:`Adds a validation error for a field within the form state.
@param messages The validation error message(s) to add.
@param identifier The identifier so use when adding the validation error(s), allows this group to be independently cleared.`,name:"addValidationError",required:!0,type:{name:"(messages: ValidationMessage | ValidationMessage[], identifier?: string | undefined) => void"}},clearClientValidationErrors:{defaultValue:null,description:`Clears all client validation errors for the current form state.
@param identifiers an optional array of validation error identifiers, if passed, only errors that match the identifier will be deleted.`,name:"clearClientValidationErrors",required:!0,type:{name:"(...identifiers: string[]) => void"}},validate:{defaultValue:null,description:`Runs specific field validator in the validators schema again the current form state.
@param setInputTouched Whether to set the targeted control to "touched" before running the validator, default: true
@param silent A boolean representing whether validation errors should be dispatched to the form elements
@param validateAll If true, the validator will run against the entire schema, not just the current field`,name:"validate",required:!0,type:{name:"(setInputTouched?: boolean | undefined, silent?: boolean | undefined, validateAll?: boolean | undefined) => boolean"}},isTouched:{defaultValue:null,description:"Whether the field input has been interacted with",name:"isTouched",required:!0,type:{name:"boolean"}},setTouched:{defaultValue:null,description:"Set the field input touched state",name:"setTouched",required:!0,type:{name:"(isTouched: boolean) => void"}},isValid:{defaultValue:null,description:"Whether the field input has any validation errors",name:"isValid",required:!0,type:{name:"boolean"}}}}}catch{}try{s.displayName="FormPropArrayExample",s.__docgenInfo={description:"",displayName:"FormPropArrayExample",props:{add:{defaultValue:null,description:`Adds a new item to an array field in the form state.
@param newItem The new item to add.

WARNING: Available to array properties only`,name:"add",required:!0,type:{name:"never"}},pop:{defaultValue:null,description:`Removes the last item from an array field in the form state.

WARNING: Available to array properties only`,name:"pop",required:!0,type:{name:"never"}},insert:{defaultValue:null,description:`Inserts a new item into an array field at a specific index.
@param newItem The new item to add.
@param index The index at which to insert the new item.

WARNING: Available to array properties only`,name:"insert",required:!0,type:{name:"never"}},remove:{defaultValue:null,description:`Removes an item from an array field at a specific index.
@param index The index at which to insert the new item.

WARNING: Available to array properties only`,name:"remove",required:!0,type:{name:"never"}}}}}catch{}try{i.displayName="BindPropsExample",i.__docgenInfo={description:"",displayName:"BindPropsExample",props:{value:{defaultValue:null,description:"The current value of the targeted property within the form data.",name:"value",required:!0,type:{name:"unknown"}},setValue:{defaultValue:null,description:"Sets a new value for the targeted property within the form data.",name:"setValue",required:!0,type:{name:"(value: unknown) => void"}},dispatch:{defaultValue:null,description:"The root dispatcher for all form actions, can be used to send complex state changes to the form binder as a whole.",name:"dispatch",required:!0,type:{name:"FormDispatcher<unknown>"}},keyChain:{defaultValue:null,description:"The chain of nesting keys used to access this property from the root of the form data object.",name:"keyChain",required:!0,type:{name:"KeyChain"}},myValidationErrors:{defaultValue:null,description:"An array of current validation errors relating to the targeted property within the form data.",name:"myValidationErrors",required:!0,type:{name:"IValidationError[]"}},formConfig:{defaultValue:null,description:`The root form configuration, these settings should be respected by all bindable components.
NOTE: any is OK here because the binding tools object does not need to know the shape of the entire form data.`,name:"formConfig",required:!1,type:{name:"IFormConfig<unknown>"}},bindConfig:{defaultValue:null,description:"The bind config specific to this property binding, these settings should be respected by all bindable components.",name:"bindConfig",required:!1,type:{name:"IBindConfig<unknown>"}},initialValue:{defaultValue:null,description:"The initial value attributed to the targeted property before any user input.",name:"initialValue",required:!0,type:{name:"unknown"}},addValidationError:{defaultValue:null,description:`Adds a validation error for a field within the form state.
@param messages (ValidationMessage | ValidationMessage[]) The validation error message(s) to add. A validation message can be a string or a JSX element, if using JSX please add a key to the element to keep the animations consistent
@param identifier The identifier so use when adding the validation error(s), allows this group to be independently cleared.`,name:"addValidationError",required:!0,type:{name:"(messages: ValidationMessage | ValidationMessage[], identifier?: string | undefined) => void"}},clearClientValidationErrors:{defaultValue:null,description:`Clears all client validation errors for the current form state.
@param identifiers an optional array of validation error identifiers, if passed, only errors that match the identifier will be deleted.`,name:"clearClientValidationErrors",required:!0,type:{name:"(...identifiers: string[]) => void"}},isTouched:{defaultValue:null,description:"Whether the field input has been interacted with",name:"isTouched",required:!0,type:{name:"boolean"}},setTouched:{defaultValue:null,description:"Set the field input touched state",name:"setTouched",required:!0,type:{name:"(isTouched: boolean) => void"}},myTouchedState:{defaultValue:null,description:"An array of touched states relating to the targeted property within the form data.",name:"myTouchedState",required:!0,type:{name:"TouchedState"}},clientValidationDispatcher:{defaultValue:null,description:`Provides access to the top level client validation dispatcher.
Used pretty much exclusively by child forms to dispatch errors for the correct key`,name:"clientValidationDispatcher",required:!0,type:{name:"ValidationDispatcher"}},touchedStateDispatcher:{defaultValue:null,description:`Provides access to the top level touched state dispatcher.
Used pretty much exclusively by child forms to dispatch touched state for the correct key`,name:"touchedStateDispatcher",required:!0,type:{name:"TouchedDispatcher"}},allTouched:{defaultValue:null,description:"Whether the parent form has been marked as touched globally",name:"allTouched",required:!0,type:{name:"boolean"}},validate:{defaultValue:null,description:`Runs specific field validator in the validators schema again the current form state.
@param setInputTouched Whether to set the targeted control to "touched" before running the validator, default: true
@param silent A boolean representing whether validation errors should be dispatched to the form elements
@param validateAll If true, the validator will run against the entire schema, not just the current field
NOTE: If no schema has been passed, this will always return \`true\``,name:"validate",required:!0,type:{name:"(setInputTouched?: boolean | undefined, silent?: boolean | undefined, validateAll?: boolean | undefined) => boolean"}},isValid:{defaultValue:null,description:"Whether the field input has any validation errors",name:"isValid",required:!0,type:{name:"boolean"}},parseValidationSchema:{defaultValue:null,description:`The method to trigger validation against the validation schema
@param keyChain The identifier for the form item to run the validation against
@param silent A boolean representing whether validation errors should be dispatched to the form elements`,name:"parseValidationSchema",required:!0,type:{name:"(keyChain?: KeyChain | undefined, silent?: boolean | undefined) => boolean"}}}}}catch{}function u(a){const e=Object.assign({h2:"h2",p:"p",code:"code",pre:"pre"},p(),a.components);return n(m,{children:[t(h,{title:"Form/Form Custom Inputs"}),`
`,t(e.h2,{id:"custom-inputs",children:t("a",{name:"custom-inputs",children:"Custom Inputs"})}),`
`,t(e.p,{children:"Creating an input that can be bound to a form property is as simple as creating a component with a bind prop that supplies the expected type as a generic."}),`
`,t(e.p,{children:"The Armstrong form library also supplies a hook that helps convert the complex binding tools into a simple value/setter."}),`
`,n(e.p,{children:["At it's simplest, this is a text input component expecting a ",t(e.code,{children:"string"})," as it's bound property:"]}),`
`,t(e.pre,{children:t(e.code,{className:"language-tsx",children:`interface ICustomTextInputProps {
  bind: IBindingProps<string>; // the "string" here can be any type, and should match the type expected in the form data.
}

const CustomTextInput: React.FC<ICustomTextInputProps> = props => {
  const [boundValue, boundOnChange, { myValidationErrorMessages }] = useBindingState(props.bind);

  return (
    <>
      <input type="text" value={boundValue} onChange={boundOnChange} />

      <ValidationErrors validationErrors={myValidationErrorMessages} />
    </>
  );
};
`})}),`
`,n(e.p,{children:["There are plenty of advanced tools within the bind prop, and the use of the ",t(e.code,{children:"useBindingState"})," prop is entirely optional, as long as you're careful to implement the features of the form binder within your custom input then you're good to go!"]}),`
`,n(e.p,{children:["Here's the full list of tools contained within a ",t(e.code,{children:"bind"})," that your custom inputs can interface with:"]}),`
`,t(c,{of:i})]})}function f(a={}){const{wrapper:e}=Object.assign({},p(),a.components);return e?t(e,{...a,children:t(u,{...a})}):u(a)}const y=()=>{throw new Error("Docs-only story")};y.parameters={docsOnly:!0};const r={title:"Form/Form Custom Inputs",tags:["stories-mdx"],includeStories:["__page"]};r.parameters=r.parameters||{};r.parameters.docs={...r.parameters.docs||{},page:f};const P=["__page"];export{P as __namedExportsOrder,y as __page,r as default};
